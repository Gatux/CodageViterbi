\documentclass[11pt]{article}

\usepackage[left=0.75in, right=0.75in, top=0.75in, bottom=0.75in]{geometry}
\usepackage{layout}
\usepackage{ucs}
\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{stmaryrd}



\title{\textbf{TS226 - TP de codage canal}\\\\Encodage et décodage de codes convolutifs}
\author{Thomas MARCHAL - Maxime PETERLIN - Gabriel VERMEULEN\\\\{ENSEIRB-MATMECA, Bordeaux}}
\date{12 juin 2014}


\begin{document}

\maketitle
			
\tableofcontents

\newpage

\section{Encodage de codes convolutifs}
	
	\subsection{Principe d'encodage d'une séquence $\textbf{m} = [m_0, \ldots, m_{L-1}]$ de bits à transmettre}
	
		Soit $n$ la longueur du code convolutif binaire.\\
		Soient $g_1(D), \ldots, g_n(D)$ les $n$ polynômes générateurs à coefficients dans $\mathbb{F}_2$ servant à encoder la séquence $\textbf{m} = [m_0, \ldots, m_{L-1}]$.
		On forme la matrice $G$ dont les lignes sont les coefficients de ces derniers. \\
		\\
		Soient $C(D)$ et $\textbf{m}(D)$ respectivement les séquences de bits encodée et à transmettre que l'on représente sous forme polynomiale.\\
		\\
		La relation permettant d'encoder le message $\textbf{m}$ est la suivante :
		\begin{align}
			C(D) &= \textbf{m}(D)G = [\textbf{m}(D)g_1(D), \ldots, \textbf{m}(D)g_n(D)]\\
					 &= [C_1(D), \ldots, C_n(D)]
		\end{align}
		\\
		La séquence envoyée est alors
		\[
			\underbrace{C_{1,0} \cdots C_{n,0}}_{t = 0}\ \ldots\ \underbrace{C_{1,t} \cdots C_{n,t}}_{instant\ t}
		\]
	
	\subsection{Mémoire M du codeur}
	
		La mémoire M du codeur est donnée par le retard maximal des registres à décalage.\\
		Mathématiquement, cela s'exprime de la manière suivante :
		\[
			M = \underset{i \in  \llbracket 1, \ldots, n \rrbracket}{max}\ deg(g_i)
		\]
		
	\subsection{Principe de fonctionnement de la fonction $codconv$}
	
		La fonction $codconv$ prend en paramètre le message à encoder \textbf{m}, ainsi qu'un vecteur $g$ composé des polynômes générateurs associés au code sous forme octale et elle renvoie la séquence de bits à transmettre \textbf{C}.\\
		\\
		On cherche à créer une matrice \textbf{C} dont les lignes seraient les coefficients des polynômes $C_i(D)$, avec $i \in  \llbracket 1, \ldots, n \rrbracket$. C'est à partir de cette matrice qu'on obtiendra la séquence à envoyer.\\
		Par souci de performances, on calcule d'avance la taille de cette matrice :
		\begin{itemize}
			\item Le nombre de lignes est égal au nombre de polynômes générateurs
			\item Le nombre de colonnes se trouve grâce à la formule permettant de calculer la taille du résultat de la convolution de deux vecteurs. En effet, comme les coefficients du produit de deux polynômes résultent de la convolution des coefficients de ces derniers, alors le produit de polynômes $\textbf{m}(D)g_i(D)$ revient à convoluer le vecteur $[m_0, \ldots, m_{L-1}]$ et le vecteur contenant les coefficients de $g_i$. Ainsi, le nombre $l$ de colonne est
			\[
				l = max\ (n+L-1,\ n,\ L)
			\]
			\\
		\end{itemize}
		\\
		\\
		Une fois que la matrice est initialisée, on la remplie de sorte que la nième ligne soit égale au produit de convolution modulo 2 du vecteur de bits \textbf{m} et du vecteur contenant les coefficients du polynômes $g_n$.\\
		\\
		Il ne reste plus qu'à modifier la taille de la matrice pour obtenir la séquence de bits à transmettre dans l'ordre défini et expliqué supra.
		
		
\section{Décodage des codes convolutifs : algorithme de Viterbi}

	\subsection{Principe de fonctionnement de la fonction $paramconv2$}

	\subsection{Principe de fonctionnement de la fonction $decodconv$}
	
	La fonction $decodconv$ prend en paramètre le message à décoder \textbf{y}, ainsi qu'un vecteur $g$ composé des polynômes générateurs associés au code sous forme octale et elle renvoie le message envoyé \textbf{m}.\\
		\\
		On commence par créer une matrice de $2^M$ lignes et $\frac{L_y}{L_g} + 1$ colonnes qui contiendra les informations relatives au treillis, avec $L_y$ la longueur du message encodé et $L_g$ le nombre de polynômes générateurs.\\
		Si $L_y$ n'est pas divisible par $L_g$, cela veut dire que la taille du message encodé et le nombre de polynômes générateurs ne correspondent pas, un message d'erreur est alors renvoyé.\\
		\\
		Chaque composante de la matrice représentant le treillis va contenir une cell qui aura la structure suivante.
		\begin{itemize}
			\item Le numéro de la ligne au temps $t-1$ menant à la cell actuelle (i.e. au temps $t$).
			\item Le poids associé à la cell actuelle.
			\item Le bit associé au chemin.
			\\
		\end{itemize}
		\\
		Le treillis va ensuite être parcouru suivant ses colonnes et ses lignes pour remplir les différentes cell en fonction du diagramme d'état du code \textbf{T}.\\
		\\
		A chaque fois qu'on arrive sur une cell que l'on peut remplir (en se basant sur la matrice \textbf{T}), alors on commence par calculer le poids du chemin\\
		Ensuite, si la cell du treillis que l'on veut créer n'existe pas, on la crée en remplissant les informations de la structure définie supra.
		Par contre, si la cell existait déjà et qu'un autre chemin y mène, alors on compare les poids de ces derniers et on retient celui de poids le plus faible.\\
		\\
		Une fois que le treillis est rempli, on le parcourt en sens inverse en partant de la cell située dans la première ligne de la dernière colonne grâce aux numéros de lignes enregistrés permettant d'identifier les noeuds précédents.\\
		\\
		Il ne reste plus qu'a supprimer les $M$ derniers bits pour ne pas prendre en compte la remise à zéro des registres.

\section{Performances}
	
		

			

\end{document}