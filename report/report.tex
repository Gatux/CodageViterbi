\documentclass[11pt]{article}

\usepackage[left=0.75in, right=0.75in, top=0.75in, bottom=0.75in]{geometry}
\usepackage{layout}
\usepackage{ucs}
\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{stmaryrd}



\title{\textbf{TS226 - TP de codage canal}\\\\Encodage et décodage de codes convolutifs}
\author{Thomas MARCHAL - Maxime PETERLIN - Gabriel VERMEULEN\\\\{ENSEIRB-MATMECA, Bordeaux}}
\date{12 juin 2014}


\begin{document}

\maketitle
			
\tableofcontents

\newpage

\section{Encodage de codes convolutifs}
	
	\subsection{Principe d'encodage d'une séquence $\textbf{m} = [m_0, \ldots, m_{L-1}]$ de bits à transmettre}
	
		Soit $n$ la longueur du code convolutif binaire.\\
		Soient $g_1(D), \ldots, g_n(D)$ les $n$ polynômes générateurs à coefficients dans $\mathbb{F}_2$ servant à encoder la séquence $\textbf{m} = [m_0, \ldots, m_{L-1}]$.
		On forme la matrice $G$ dont les lignes sont les coefficients de ces derniers. \\
		\\
		Soient $C(D)$ et $\textbf{m}(D)$ respectivement les séquences de bits encodée et à transmettre que l'on représente sous forme polynomiale.\\
		\\
		La relation permettant d'encoder le message $\textbf{m}$ est la suivante :
		\begin{align}
			C(D) &= \textbf{m}(D)G = [\textbf{m}(D)g_1(D), \ldots, \textbf{m}(D)g_n(D)]\\
					 &= [C_1(D), \ldots, C_n(D)]
		\end{align}
		\\
		La séquence envoyée est alors
		\[
			\underbrace{C_{1,0} \cdots C_{n,0}}_{t = 0}\ \ldots\ \underbrace{C_{1,t} \cdots C_{n,t}}_{instant\ t}
		\]
	
	\subsection{Mémoire M du codeur}
	
		La mémoire M du codeur est donnée par le retard maximal des registres à décalage.\\
		Mathématiquement, cela s'exprime de la manière suivante :
		\[
			M = \underset{i \in  \llbracket 1, \ldots, n \rrbracket}{max}\ deg(g_i)
		\]
		
	\subsection{Principe de fonctionnement de la fonction $codconv$}
	
		La fonction $codconv$ prend en paramètre le message à encoder \textbf{m}, ainsi qu'un vecteur $g$ composé des polynômes générateurs associés au code sous forme octale et elle renvoie la séquence de bits à transmettre \textbf{C}.\\
		\\
		On cherche à créer une matrice \textbf{C} dont les lignes seraient les coefficients des polynômes $C_i(D)$, avec $i \in  \llbracket 1, \ldots, n \rrbracket$. C'est à partir de cette matrice qu'on obtiendra la séquence à envoyer.\\
		Par souci de performances, on calcule d'avance la taille de cette matrice :
		\begin{itemize}
			\item Le nombre de lignes est égal au nombre de polynômes générateurs
			\item Le nombre de colonnes se trouve grâce à la formule permettant de calculer la taille du résultat de la convolution de deux vecteurs. En effet, comme les coefficients du produit de deux polynômes résultent de la convolution des coefficients de ces derniers, alors le produit de polynômes $\textbf{m}(D)g_i(D)$ revient à convoluer le vecteur $[m_0, \ldots, m_{L-1}]$ et le vecteur contenant les coefficients de $g_i$. Ainsi, le nombre $l$ de colonne est
			\[
				l = max\ (n+L-1,\ n,\ L)
			\]
			\\
		\end{itemize}
		\\
		\\
		Une fois que la matrice est initialisée, on la remplie de sorte que la nième ligne soit égale au produit de convolution modulo 2 du vecteur de bits \textbf{m} et du vecteur contenant les coefficients du polynômes $g_n$.\\
		\\
		Il ne reste plus qu'à modifier la taille de la matrice pour obtenir la séquence de bits à transmettre dans l'ordre défini et expliqué supra.
		
		
\section{Décodage des codes convolutifs : algorithme de Viterbi}

	\subsection{Principe de fonctionnement de la fonction $paramconv2$}
		La fonction $paramconv2$ prend en paramètre un vecteur représentant les polynômes générateurs, en utilisant le système octal. Le but de cette fonction est de renvoyer une matrice T qui représente le diagramme d'état du code, où $\textbf{T}_{i,j}$ contient la sortie de l'encodeur associée à l'arête reliant l'état i à l'état j, sous forme décimale.\\
		\\
		On commence par tranformer les données octales des polynômes générateurs en binaire avec les fonctions $base2dec$ et $dec2bin$. On calcule M en prenant $M = \underset{i \in  \llbracket 1, \ldots, n \rrbracket}{max}\ deg(g_i)$, et on génère une matrice de taille $2^M$ initialisé à -1 pour différencier les arêtes utiles des non-existantes.\\
		Ensuite on remplie la matrice aux endroits où les arètes existent, c'est-à-dire pour chaque couple de lignes $i$ et $i+1$ de la matrice, aux colonnes $i$ et $2^(M-1)$. Pour ce faire on effectue le calcul des équations de convolutions, obtenue à partir des polynômes générateurs et des états possibles des registres.\\
		Ainsi on obtient la matrice du diagramme d'état du code.
		
	\subsection{Principe de fonctionnement de la fonction $decodconv$}


\section{Performances}
	
		

			

\end{document}